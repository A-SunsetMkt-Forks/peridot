/*
 * peridot/proto/v1/batch.proto
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: version not set
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package peridotopenapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type BuildServiceApi interface {

	/*
	 * GetBuild GetBuild returns a build by its id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param projectId
	 * @param buildId
	 * @return ApiGetBuildRequest
	 */
	GetBuild(ctx _context.Context, projectId string, buildId string) ApiGetBuildRequest

	/*
	 * GetBuildExecute executes the request
	 * @return V1GetBuildResponse
	 */
	GetBuildExecute(r ApiGetBuildRequest) (V1GetBuildResponse, *_nethttp.Response, error)

	/*
	 * GetBuildBatch GetBuildBatch returns a build batch by its id
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param projectId
	 * @param buildBatchId
	 * @return ApiGetBuildBatchRequest
	 */
	GetBuildBatch(ctx _context.Context, projectId string, buildBatchId string) ApiGetBuildBatchRequest

	/*
	 * GetBuildBatchExecute executes the request
	 * @return V1GetBuildBatchResponse
	 */
	GetBuildBatchExecute(r ApiGetBuildBatchRequest) (V1GetBuildBatchResponse, *_nethttp.Response, error)

	/*
	 * ListBuildBatches ListBuildBatches returns all build batches
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param projectId
	 * @return ApiListBuildBatchesRequest
	 */
	ListBuildBatches(ctx _context.Context, projectId string) ApiListBuildBatchesRequest

	/*
	 * ListBuildBatchesExecute executes the request
	 * @return V1ListBuildBatchesResponse
	 */
	ListBuildBatchesExecute(r ApiListBuildBatchesRequest) (V1ListBuildBatchesResponse, *_nethttp.Response, error)

	/*
	 * ListBuilds ListBuilds returns all builds filtered through given filters
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param projectId
	 * @return ApiListBuildsRequest
	 */
	ListBuilds(ctx _context.Context, projectId string) ApiListBuildsRequest

	/*
	 * ListBuildsExecute executes the request
	 * @return V1ListBuildsResponse
	 */
	ListBuildsExecute(r ApiListBuildsRequest) (V1ListBuildsResponse, *_nethttp.Response, error)

	/*
	 * RpmImport RpmImport imports rpm files into a project (packaged into tar format)
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param projectId
	 * @return ApiRpmImportRequest
	 */
	RpmImport(ctx _context.Context, projectId string) ApiRpmImportRequest

	/*
	 * RpmImportExecute executes the request
	 * @return V1AsyncTask
	 */
	RpmImportExecute(r ApiRpmImportRequest) (V1AsyncTask, *_nethttp.Response, error)

	/*
	 * RpmLookasideBatchImport RpmLookasideBatchImport imports rpm files into a project (stored in Lookaside)
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param projectId
	 * @return ApiRpmLookasideBatchImportRequest
	 */
	RpmLookasideBatchImport(ctx _context.Context, projectId string) ApiRpmLookasideBatchImportRequest

	/*
	 * RpmLookasideBatchImportExecute executes the request
	 * @return V1AsyncTask
	 */
	RpmLookasideBatchImportExecute(r ApiRpmLookasideBatchImportRequest) (V1AsyncTask, *_nethttp.Response, error)

	/*
	 * SubmitBuild SubmitBuild builds a package scoped to a project The project has to contain an import for the specific package This method is asynchronous. Peridot uses the AsyncTask abstraction. Check out `//peridot/proto/v1:task.proto` for more information
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param projectId Project ID that we want this build to be assigned to All build requests need a project id, however after the initial import, sharing the VRE in an inter-project way is possible.
	 * @return ApiSubmitBuildRequest
	 */
	SubmitBuild(ctx _context.Context, projectId string) ApiSubmitBuildRequest

	/*
	 * SubmitBuildExecute executes the request
	 * @return V1AsyncTask
	 */
	SubmitBuildExecute(r ApiSubmitBuildRequest) (V1AsyncTask, *_nethttp.Response, error)

	/*
	 * SubmitBuildBatch SubmitBuildBatch submits a batch of builds.
	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param projectId Only the top-most project id is used for all build requests
	 * @return ApiSubmitBuildBatchRequest
	 */
	SubmitBuildBatch(ctx _context.Context, projectId string) ApiSubmitBuildBatchRequest

	/*
	 * SubmitBuildBatchExecute executes the request
	 * @return V1SubmitBuildBatchResponse
	 */
	SubmitBuildBatchExecute(r ApiSubmitBuildBatchRequest) (V1SubmitBuildBatchResponse, *_nethttp.Response, error)
}

// BuildServiceApiService BuildServiceApi service
type BuildServiceApiService service

type ApiGetBuildRequest struct {
	ctx _context.Context
	ApiService BuildServiceApi
	projectId string
	buildId string
}


func (r ApiGetBuildRequest) Execute() (V1GetBuildResponse, *_nethttp.Response, error) {
	return r.ApiService.GetBuildExecute(r)
}

/*
 * GetBuild GetBuild returns a build by its id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @param buildId
 * @return ApiGetBuildRequest
 */
func (a *BuildServiceApiService) GetBuild(ctx _context.Context, projectId string, buildId string) ApiGetBuildRequest {
	return ApiGetBuildRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		buildId: buildId,
	}
}

/*
 * Execute executes the request
 * @return V1GetBuildResponse
 */
func (a *BuildServiceApiService) GetBuildExecute(r ApiGetBuildRequest) (V1GetBuildResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1GetBuildResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildServiceApiService.GetBuild")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/builds/{buildId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"buildId"+"}", _neturl.PathEscape(parameterToString(r.buildId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBuildBatchRequest struct {
	ctx _context.Context
	ApiService BuildServiceApi
	projectId string
	buildBatchId string
	page *int32
	limit *int32
	filterStatus *string
}

func (r ApiGetBuildBatchRequest) Page(page int32) ApiGetBuildBatchRequest {
	r.page = &page
	return r
}
func (r ApiGetBuildBatchRequest) Limit(limit int32) ApiGetBuildBatchRequest {
	r.limit = &limit
	return r
}
func (r ApiGetBuildBatchRequest) FilterStatus(filterStatus string) ApiGetBuildBatchRequest {
	r.filterStatus = &filterStatus
	return r
}

func (r ApiGetBuildBatchRequest) Execute() (V1GetBuildBatchResponse, *_nethttp.Response, error) {
	return r.ApiService.GetBuildBatchExecute(r)
}

/*
 * GetBuildBatch GetBuildBatch returns a build batch by its id
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @param buildBatchId
 * @return ApiGetBuildBatchRequest
 */
func (a *BuildServiceApiService) GetBuildBatch(ctx _context.Context, projectId string, buildBatchId string) ApiGetBuildBatchRequest {
	return ApiGetBuildBatchRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		buildBatchId: buildBatchId,
	}
}

/*
 * Execute executes the request
 * @return V1GetBuildBatchResponse
 */
func (a *BuildServiceApiService) GetBuildBatchExecute(r ApiGetBuildBatchRequest) (V1GetBuildBatchResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1GetBuildBatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildServiceApiService.GetBuildBatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/build_batches/{buildBatchId}"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"buildBatchId"+"}", _neturl.PathEscape(parameterToString(r.buildBatchId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.filterStatus != nil {
		localVarQueryParams.Add("filter.status", parameterToString(*r.filterStatus, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBuildBatchesRequest struct {
	ctx _context.Context
	ApiService BuildServiceApi
	projectId string
	page *int32
	limit *int32
}

func (r ApiListBuildBatchesRequest) Page(page int32) ApiListBuildBatchesRequest {
	r.page = &page
	return r
}
func (r ApiListBuildBatchesRequest) Limit(limit int32) ApiListBuildBatchesRequest {
	r.limit = &limit
	return r
}

func (r ApiListBuildBatchesRequest) Execute() (V1ListBuildBatchesResponse, *_nethttp.Response, error) {
	return r.ApiService.ListBuildBatchesExecute(r)
}

/*
 * ListBuildBatches ListBuildBatches returns all build batches
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @return ApiListBuildBatchesRequest
 */
func (a *BuildServiceApiService) ListBuildBatches(ctx _context.Context, projectId string) ApiListBuildBatchesRequest {
	return ApiListBuildBatchesRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return V1ListBuildBatchesResponse
 */
func (a *BuildServiceApiService) ListBuildBatchesExecute(r ApiListBuildBatchesRequest) (V1ListBuildBatchesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1ListBuildBatchesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildServiceApiService.ListBuildBatches")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/build_batches"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBuildsRequest struct {
	ctx _context.Context
	ApiService BuildServiceApi
	projectId string
	filtersStatus *string
	filtersPackageName *string
	page *int32
	limit *int32
}

func (r ApiListBuildsRequest) FiltersStatus(filtersStatus string) ApiListBuildsRequest {
	r.filtersStatus = &filtersStatus
	return r
}
func (r ApiListBuildsRequest) FiltersPackageName(filtersPackageName string) ApiListBuildsRequest {
	r.filtersPackageName = &filtersPackageName
	return r
}
func (r ApiListBuildsRequest) Page(page int32) ApiListBuildsRequest {
	r.page = &page
	return r
}
func (r ApiListBuildsRequest) Limit(limit int32) ApiListBuildsRequest {
	r.limit = &limit
	return r
}

func (r ApiListBuildsRequest) Execute() (V1ListBuildsResponse, *_nethttp.Response, error) {
	return r.ApiService.ListBuildsExecute(r)
}

/*
 * ListBuilds ListBuilds returns all builds filtered through given filters
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @return ApiListBuildsRequest
 */
func (a *BuildServiceApiService) ListBuilds(ctx _context.Context, projectId string) ApiListBuildsRequest {
	return ApiListBuildsRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return V1ListBuildsResponse
 */
func (a *BuildServiceApiService) ListBuildsExecute(r ApiListBuildsRequest) (V1ListBuildsResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1ListBuildsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildServiceApiService.ListBuilds")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.filtersStatus != nil {
		localVarQueryParams.Add("filters.status", parameterToString(*r.filtersStatus, ""))
	}
	if r.filtersPackageName != nil {
		localVarQueryParams.Add("filters.packageName", parameterToString(*r.filtersPackageName, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRpmImportRequest struct {
	ctx _context.Context
	ApiService BuildServiceApi
	projectId string
	body *InlineObject3
}

func (r ApiRpmImportRequest) Body(body InlineObject3) ApiRpmImportRequest {
	r.body = &body
	return r
}

func (r ApiRpmImportRequest) Execute() (V1AsyncTask, *_nethttp.Response, error) {
	return r.ApiService.RpmImportExecute(r)
}

/*
 * RpmImport RpmImport imports rpm files into a project (packaged into tar format)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @return ApiRpmImportRequest
 */
func (a *BuildServiceApiService) RpmImport(ctx _context.Context, projectId string) ApiRpmImportRequest {
	return ApiRpmImportRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return V1AsyncTask
 */
func (a *BuildServiceApiService) RpmImportExecute(r ApiRpmImportRequest) (V1AsyncTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AsyncTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildServiceApiService.RpmImport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/builds/rpm-import"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRpmLookasideBatchImportRequest struct {
	ctx _context.Context
	ApiService BuildServiceApi
	projectId string
	body *InlineObject4
}

func (r ApiRpmLookasideBatchImportRequest) Body(body InlineObject4) ApiRpmLookasideBatchImportRequest {
	r.body = &body
	return r
}

func (r ApiRpmLookasideBatchImportRequest) Execute() (V1AsyncTask, *_nethttp.Response, error) {
	return r.ApiService.RpmLookasideBatchImportExecute(r)
}

/*
 * RpmLookasideBatchImport RpmLookasideBatchImport imports rpm files into a project (stored in Lookaside)
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId
 * @return ApiRpmLookasideBatchImportRequest
 */
func (a *BuildServiceApiService) RpmLookasideBatchImport(ctx _context.Context, projectId string) ApiRpmLookasideBatchImportRequest {
	return ApiRpmLookasideBatchImportRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return V1AsyncTask
 */
func (a *BuildServiceApiService) RpmLookasideBatchImportExecute(r ApiRpmLookasideBatchImportRequest) (V1AsyncTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AsyncTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildServiceApiService.RpmLookasideBatchImport")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/builds/rpm-lookaside-batch-import"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitBuildRequest struct {
	ctx _context.Context
	ApiService BuildServiceApi
	projectId string
	body *InlineObject2
}

func (r ApiSubmitBuildRequest) Body(body InlineObject2) ApiSubmitBuildRequest {
	r.body = &body
	return r
}

func (r ApiSubmitBuildRequest) Execute() (V1AsyncTask, *_nethttp.Response, error) {
	return r.ApiService.SubmitBuildExecute(r)
}

/*
 * SubmitBuild SubmitBuild builds a package scoped to a project The project has to contain an import for the specific package This method is asynchronous. Peridot uses the AsyncTask abstraction. Check out `//peridot/proto/v1:task.proto` for more information
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Project ID that we want this build to be assigned to All build requests need a project id, however after the initial import, sharing the VRE in an inter-project way is possible.
 * @return ApiSubmitBuildRequest
 */
func (a *BuildServiceApiService) SubmitBuild(ctx _context.Context, projectId string) ApiSubmitBuildRequest {
	return ApiSubmitBuildRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return V1AsyncTask
 */
func (a *BuildServiceApiService) SubmitBuildExecute(r ApiSubmitBuildRequest) (V1AsyncTask, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1AsyncTask
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildServiceApiService.SubmitBuild")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/builds"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubmitBuildBatchRequest struct {
	ctx _context.Context
	ApiService BuildServiceApi
	projectId string
	body *InlineObject1
}

func (r ApiSubmitBuildBatchRequest) Body(body InlineObject1) ApiSubmitBuildBatchRequest {
	r.body = &body
	return r
}

func (r ApiSubmitBuildBatchRequest) Execute() (V1SubmitBuildBatchResponse, *_nethttp.Response, error) {
	return r.ApiService.SubmitBuildBatchExecute(r)
}

/*
 * SubmitBuildBatch SubmitBuildBatch submits a batch of builds.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param projectId Only the top-most project id is used for all build requests
 * @return ApiSubmitBuildBatchRequest
 */
func (a *BuildServiceApiService) SubmitBuildBatch(ctx _context.Context, projectId string) ApiSubmitBuildBatchRequest {
	return ApiSubmitBuildBatchRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

/*
 * Execute executes the request
 * @return V1SubmitBuildBatchResponse
 */
func (a *BuildServiceApiService) SubmitBuildBatchExecute(r ApiSubmitBuildBatchRequest) (V1SubmitBuildBatchResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1SubmitBuildBatchResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BuildServiceApiService.SubmitBuildBatch")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/projects/{projectId}/build_batches"
	localVarPath = strings.Replace(localVarPath, "{"+"projectId"+"}", _neturl.PathEscape(parameterToString(r.projectId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v RpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
